"""
Email Validator Module
Handles SMTP-based email validation without sending actual emails.
"""

import re
import random
import string
import urllib.request
import urllib.error
import json
from typing import Dict, Tuple, Optional
from email_validator import validate_email, EmailNotValidError
from validate_email import validate_email as validate_email_py3


class EmailValidator:
    """Validate email addresses using SMTP without sending emails."""

    def __init__(self, sender_email: str = "verify@yourdomain.com", use_third_party: bool = False, third_party_provider: str = "rapid"):
        """
        Initialize the email validator.

        Args:
            sender_email (str): Sender address for SMTP handshake (can be fake but must be valid format)
        """
        self.sender_email = sender_email
        self.use_third_party = use_third_party
        self.third_party_provider = third_party_provider
        # Use boundary after TLD to avoid trailing garbage affecting fallback normalization
        self.email_pattern = re.compile(r'[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}(?=[^A-Za-z]|$)', re.IGNORECASE)
        # Optional shared normalizer from ContactExtractor
        try:
            from contact_extractor import ContactExtractor
            self._extractor = ContactExtractor()
        except Exception:
            self._extractor = None

    def validate_email(self, email: str) -> Dict[str, any]:
        """
        Validate email deliverability via SMTP without sending actual emails.

        Args:
            email (str): Target email to validate

        Returns:
            Dict: Validation result with detailed information
        """
        result = {
            'valid': False,
            'reason': '',
            'catch_all': False,
            'mx_records': [],
            'smtp_response': ''
        }

        # Basic format validation first using email-validator
        try:
            validated_email = validate_email(email, check_deliverability=False)
            normalized_email = validated_email.normalized
        except EmailNotValidError as e:
            result['reason'] = 'invalid_format'
            result['smtp_response'] = str(e)
            return result

        try:
            # Use validate_email for comprehensive validation
            validation_result = validate_email_py3(
                email_address=normalized_email
            )

            if validation_result is True:
                result['valid'] = True
                result['reason'] = 'valid'

                # Check for catch-all domain
                catch_all_result = self._check_catch_all(normalized_email)
                result['catch_all'] = catch_all_result

                if catch_all_result:
                    result['reason'] = 'catch_all'

            elif validation_result is False:
                result['reason'] = 'smtp_invalid'
            else:  # validation_result is None (ambiguous)
                result['valid'] = True  # Consider ambiguous as potentially valid
                result['reason'] = 'possibly_valid'

        except Exception as e:
            error_str = str(e).lower()

            # Categorize common errors
            if 'timeout' in error_str:
                result['reason'] = 'smtp_timeout'
            elif 'connection' in error_str or 'refused' in error_str:
                result['reason'] = 'connection_refused'
            elif 'mx' in error_str or 'dns' in error_str:
                result['reason'] = 'mx_not_found'
            elif 'blocked' in error_str or 'blacklist' in error_str:
                result['reason'] = 'blocked'
            elif 'greylist' in error_str:
                result['reason'] = 'greylisted'
            elif 'blacklisted' in error_str or 'disposable' in error_str:
                result['reason'] = 'disposable_email'
            else:
                result['reason'] = 'smtp_error'

            result['smtp_response'] = str(e)

        # Optional: third-party fallback when local result is ambiguous or blocked
        if self.use_third_party and self._should_fallback_to_third_party(result.get('reason')):
            tp_res = None
            if self.third_party_provider == 'rapid':
                tp_res = self._verify_with_rapid(normalized_email)

            if tp_res:
                merged = dict(result)
                # Prefer definitive statuses from third-party, keep local fields
                merged['smtp_response'] = tp_res.get('smtp_response') or merged.get('smtp_response', '')
                if tp_res.get('mx_records'):
                    merged['mx_records'] = merged.get('mx_records') or tp_res['mx_records']
                if tp_res.get('valid') or tp_res.get('reason') in ('invalid_format', 'domain_not_found', 'disposable_email'):
                    merged['valid'] = tp_res['valid']
                    merged['reason'] = tp_res['reason']
                result = merged

        return result

    def _is_valid_email_format(self, email: str) -> bool:
        """
        Check if email has valid format.

        Args:
            email (str): Email to check

        Returns:
            bool: True if format is valid
        """
        if not email or not isinstance(email, str):
            return False

        email = email.strip()

        # Basic checks
        if '@' not in email or email.count('@') != 1:
            return False

        local, domain = email.split('@')

        # Check local part
        if not local or len(local) > 64:
            return False

        # Check domain part
        if not domain or len(domain) > 255 or '.' not in domain:
            return False

        # Regex validation
        return bool(self.email_pattern.match(email))

    def _check_catch_all(self, email: str) -> bool:
        """
        Check if the domain is a catch-all domain by testing random addresses.

        Args:
            email (str): Email to check domain for

        Returns:
            bool: True if domain appears to be catch-all
        """
        try:
            domain = email.split('@')[1]

            # Generate random email addresses for the same domain
            random_emails = []
            for _ in range(2):  # Test 2 random addresses
                random_local = ''.join(random.choices(string.ascii_lowercase + string.digits, k=10))
                random_email = f"{random_local}@{domain}"
                random_emails.append(random_email)

            valid_count = 0
            for random_email in random_emails:
                try:
                    # Use validate_email for catch-all testing
                    result = validate_email_py3(
                        email_address=random_email
                    )
                    if result is True:
                        valid_count += 1
                except:
                    pass

            # If multiple random emails are valid, likely catch-all
            return valid_count >= 2

        except Exception:
            return False

    def _categorize_error(self, error_message: str) -> str:
        """
        Categorize error message into standard reason codes.

        Args:
            error_message (str): Error message from validator

        Returns:
            str: Standardized error reason
        """
        error_lower = error_message.lower()

        if 'mailbox' in error_lower and ('not' in error_lower or 'invalid' in error_lower):
            return 'mailbox_not_found'
        elif 'domain' in error_lower and ('not' in error_lower or 'invalid' in error_lower):
            return 'domain_not_found'
        elif 'mx' in error_lower:
            return 'mx_not_found'
        elif 'timeout' in error_lower:
            return 'smtp_timeout'
        elif 'connection' in error_lower:
            return 'connection_refused'
        elif 'blocked' in error_lower or 'spam' in error_lower:
            return 'blocked'
        elif 'greylist' in error_lower:
            return 'greylisted'
        elif 'quota' in error_lower or 'full' in error_lower:
            return 'mailbox_full'
        else:
            return 'smtp_invalid'

    def validate_batch(self, emails: list) -> Dict[str, Dict]:
        """
        Validate multiple emails in batch.

        Args:
            emails (list): List of email addresses to validate

        Returns:
            Dict[str, Dict]: Dictionary mapping email to validation result
        """
        results = {}

        for email in emails:
            if not email or not isinstance(email, str):
                continue

            raw = email.strip().lower()
            normalized = None

            # Prefer robust normalization via ContactExtractor if available
            if self._extractor:
                try:
                    normalized = self._extractor._normalize_email(raw)
                except Exception:
                    normalized = None

            # Fallback: use regex to grab the core email if normalizer is not available
            if not normalized:
                m = self.email_pattern.search(raw)
                normalized = m.group(0) if m else None

            # If still not normalizable, categorize as invalid_format
            if not normalized:
                results[raw] = {
                    'valid': False,
                    'reason': 'invalid_format',
                    'catch_all': False,
                    'mx_records': [],
                    'smtp_response': 'Normalization failed'
                }
                continue

            results[normalized] = self.validate_email(normalized)

        return results

    # --- Third-party fallback helpers ---
    def _should_fallback_to_third_party(self, reason: Optional[str]) -> bool:
        """Decide whether to call third-party verifier based on local reason."""
        if not reason:
            return False
        return reason in {
            'policy_denied',
            'blocked',
            'greylisted',
            'smtp_timeout',
            'connection_refused',
            'smtp_error',
            'possibly_valid'
        }

    def _verify_with_rapid(self, email: str) -> Dict[str, any]:
        """Call free Rapid Email Verifier API without extra dependencies.

        Endpoint: https://rapid-email-verifier.fly.dev/api/validate
        Returns mapped dict to internal format: valid, reason, mx_records, smtp_response
        """
        try:
            payload = json.dumps({'email': email}).encode('utf-8')
            req = urllib.request.Request(
                url='https://rapid-email-verifier.fly.dev/api/validate',
                data=payload,
                headers={'Content-Type': 'application/json'},
                method='POST'
            )
            with urllib.request.urlopen(req, timeout=8) as resp:
                body = resp.read()
                data = json.loads(body.decode('utf-8'))
        except urllib.error.HTTPError as e:
            try:
                err_body = e.read().decode('utf-8')
            except Exception:
                err_body = str(e)
            return {
                'valid': False,
                'reason': 'third_party_error',
                'mx_records': [],
                'smtp_response': err_body
            }
        except Exception as e:
            return {
                'valid': False,
                'reason': 'third_party_error',
                'mx_records': [],
                'smtp_response': str(e)
            }

        status = str(data.get('status', '')).upper()
        validations = data.get('validations', {}) or {}

        # Map provider status to internal reason and validity
        if status == 'VALID':
            valid = True
            reason = 'valid'
        elif status == 'PROBABLY_VALID':
            valid = True
            reason = 'possibly_valid'
        elif status == 'INVALID_FORMAT':
            valid = False
            reason = 'invalid_format'
        elif status == 'INVALID_DOMAIN':
            valid = False
            reason = 'domain_not_found'
        elif status == 'DISPOSABLE':
            valid = False
            reason = 'disposable_email'
        else:
            valid = False
            reason = 'smtp_invalid'

        mx_records = []
        try:
            if validations.get('mx_records') is True:
                mx_records = ['MX_PRESENT']
        except Exception:
            mx_records = []

        return {
            'valid': valid,
            'reason': reason,
            'mx_records': mx_records,
            'smtp_response': f'third_party_status={status}'
        }
